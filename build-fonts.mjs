// build-fonts.mjs
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import Fontmin from 'fontmin';
import { execSync } from 'child_process';

const fontkit = await import('fontkit').then(mod => mod.default || mod);

// === Paths ===
const __dirname = path.dirname(fileURLToPath(import.meta.url));
const RAW_FONT_DIR = path.resolve(__dirname, 'public/src_fonts');
const OUTPUT_FONT_DIR = path.resolve(__dirname, 'public/fonts');
const EJS_EXPORT_PATH = path.resolve(__dirname, 'templates/partials/globalStyles.ejs');
const JS_EXPORT_PATH = path.resolve(__dirname, 'templates/partials/customFonts.js');
const HTML_TEMPLATE_PATH = path.resolve(__dirname, 'templates/index.ejs');
const SIZE_THRESHOLD_MB = 0.5;
const CLEANUP_ORIGINAL = true;

// === Utilities ===
fs.mkdirSync(OUTPUT_FONT_DIR, { recursive: true });

function extractUnicodeSubset(htmlPath) {
    try {
        console.log(`ðŸ” Extracting glyphs from: ${htmlPath}`);
        const output = execSync(`glyphhanger ${htmlPath} --LATIN --subset=tmp.txt --json`, { encoding: 'utf-8' });
        const json = JSON.parse(output);
        return json.subsets?.['tmp.txt'] || 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    } catch {
        console.warn('âš ï¸ Glyphhanger fallback.');
        return 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789.,!?';
    }
}

function getLargeFontFiles() {
    return fs.readdirSync(RAW_FONT_DIR)
        .filter(f => /\.(ttf|otf)$/i.test(f))
        .filter(f => fs.statSync(path.join(RAW_FONT_DIR, f)));
        // .filter(f => fs.statSync(path.join(RAW_FONT_DIR, f)).size > SIZE_THRESHOLD_MB * 1024 * 1024);
}

function getFontStyleWeight(fileName) {
    const lower = fileName.toLowerCase();
    return {
        weight: /bold/.test(lower) ? 'bold' : /black/.test(lower) ? '900' : 'normal',
        style: /italic/.test(lower) || /oblique/.test(lower) ? 'italic' : 'normal'
    };
}

function getFontFamilyName(fontPath, fallback) {
    try {
        const font = fontkit.openSync(fontPath);
        return font.fullName || font.familyName || fallback;
    } catch {
        return fallback;
    }
}

function compressFont(file, text) {
    const inputPath = path.join(RAW_FONT_DIR, file);
    const baseName = path.basename(file, path.extname(file));

    const fontmin = new Fontmin()
        .src(inputPath)
        .use(Fontmin.glyph({ text }))
        .use(Fontmin.ttf2woff())
        .use(Fontmin.ttf2woff2())
        .dest(OUTPUT_FONT_DIR);

    return new Promise((resolve, reject) => {
        fontmin.run((err) => {
            if (err) reject(err);
            else {
                if (CLEANUP_ORIGINAL) fs.unlinkSync(inputPath);
                resolve({ baseName, originalFile: file });
            }
        });
    });
}

// === Generate BOTH JS + EJS from same data
function generateFontOutputs(fontFiles) {
    const aliasMap = {};
    const cssBlocks = [];

    for (const { baseName, originalFile } of fontFiles) {
        const fullPath = path.join(OUTPUT_FONT_DIR, baseName + '.woff2');
        const rawFontPath = path.join(RAW_FONT_DIR, originalFile);
        const { weight, style } = getFontStyleWeight(originalFile);
        const family = getFontFamilyName(rawFontPath, baseName);

        aliasMap[baseName] = family;

        cssBlocks.push(`
            <link rel="preload" as="font" href="/fonts/${baseName}.woff2" type="font/woff2" crossorigin="anonymous">
            @font-face {
                font-family: '${family}';
                src: url('/fonts/${baseName}.woff2') format('woff2'),
                    url('/fonts/${baseName}.woff') format('woff');
                font-weight: ${weight};
                font-style: ${style};
                font-display: swap;
            }
        `);
    }

    // === Write customFonts.js
    const aliasExport = 'const ALIASES = ' + JSON.stringify(aliasMap, null, 2) + ';\n';
    const fontExport = 'const customFonts = `' + cssBlocks.join('\n').trim() + '`;\n';
    const jsContent = `// auto-generated by build-fonts.mjs\n${aliasExport}\n${fontExport}\nexport { ALIASES, customFonts };`;
    fs.writeFileSync(JS_EXPORT_PATH, jsContent, 'utf8');
    console.log(`âœ… Generated JS: ${JS_EXPORT_PATH}`);

    // === Write customFonts.ejs (EJS-friendly)
    const ejsContent = cssBlocks.join('\n').trim();
    fs.writeFileSync(EJS_EXPORT_PATH, ejsContent, 'utf8');
    console.log(`âœ… Generated EJS: ${EJS_EXPORT_PATH}`);
}

// === Main Runner
async function main() {
    console.log('ðŸš€ Starting font build...');

    const usedText = extractUnicodeSubset(HTML_TEMPLATE_PATH);
    const fontFiles = getLargeFontFiles();

    if (fontFiles.length === 0) {
        console.log('ðŸŸ¡ No large fonts to process in ./public/src_fonts/');
        return;
    }

    const processed = [];
    for (const file of fontFiles) {
        console.log(`ðŸ“¦ Compressing: ${file}`);
        const compressed = await compressFont(file, usedText);
        processed.push(compressed);
    }

    generateFontOutputs(processed);
    console.log('ðŸŽ‰ Done! Fonts optimized and both exports ready.');
}

main();
